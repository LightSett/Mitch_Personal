NAME,DESCRIPTION,TYPE,SUBTYPE,FIELD,ISEDITABLE,TRIGGERINSERT,TRIGGERDELETE,TRIGGERUPDATE,SCRIPTEXPRESSION,ERRORNUMBER,ERRORMESSAGE,EXCLUDECLIENTEVALUATION,ISENABLED,BATCH,SEVERITY,TAGS,CATEGORY,CHECKPARAMETERS
Work Order ID,,CALCULATION,,WORK_ORDER_ID,True,True,False,True,"var FDAs = Intersects($feature,FeatureSetByName($datastore,'FDA',[""WORK_ORDER_ID""],true))
var FDA = First(FDAs)
if (Count(FDAs) > 1) {
    FDA = First(Intersects(Geometry($feature)['paths'][-1][-1],FeatureSetByName($datastore,'FDA',[""WORK_ORDER_ID""],true)))
}
iif(IsEmpty(FDA),null,FDA.WORK_ORDER_ID)",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
Calculated Length,,CALCULATION,,CALCULATED_LENGTH,True,True,False,True,"//Check for geometry change upon edit and only calculate length if geometry changes
var oldGeo = geometry($originalFeature)
var newGeo = geometry($feature)
if (Equals(newGeo, oldGeo)) {return $feature.Calculated_Length}

var Spans = FeatureSetByName($datastore,'Span',['ObjectID'],true)
var intSpans = Contains($feature,Spans)

var Len = 0
for (var S in intSpans) {
  Len += Ceil(LengthGeodetic(S,'feet'))
}

return Len",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
Formatted Length,,CALCULATION,,STRAND_LEN,True,True,False,True,"//Check for geometry change upon edit and only calculate length if geometry changes
var oldGeo = geometry($originalFeature)
var newGeo = geometry($feature)
iif(Equals(newGeo, oldGeo),  Round($feature.CALCULATED_LENGTH,0) + '\'', Round(LengthGeodetic($feature, 'feet'),0) + '\'')",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
From Strand,,CALCULATION,,From_Strand,True,True,False,True,"Console($feature.ObjectID)
var Strands = FeatureSetByName($datastore,'Strand',[""ObjectID"",""STRAND_ID"",'GlobalID'],true)
var Froms = Intersects(Geometry($feature)['paths'][0][0], Strands)
var IDs = []
for (var F in Froms) {
    if (F.ObjectID==$feature.ObjectID) {continue}
    Push(IDs,Text(F.ObjectID))
}
Console(IDs)
return IDs",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
To Strand,,CALCULATION,,To_Strand,True,True,False,True,"Console($feature.ObjectID)
var Strands = FeatureSetByName($datastore,'Strand',[""ObjectID"",""STRAND_ID"",'GlobalID'],true)
var Tos = Intersects(Geometry($feature)['paths'][-1][-1], Strands)
Console(Count(Tos))
var IDs = []
for (var T in Tos) {
    if (T.ObjectID==$feature.ObjectID) {continue}
    Push(IDs,Text(T.ObjectID))
}
Console(IDs)
return IDs",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
From Structure,,CALCULATION,,From_Structure,True,True,False,True,"var STRs = FeatureSetByName($datastore,""UG_Structure"",['ObjectID',""STR_ID"",'SUBTYPE_CODE','GlobalID','Pole_GUID'],true)
var Froms = Intersects((Geometry($feature)['paths'][0][0]), STRs)
var IDs = []
for (var F in Froms) {
    Push(IDs,Text(F.ObjectID))
}
Console(IDs)
return IDs",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
To Structure,,CALCULATION,,To_Structure,True,True,False,True,"var STRs = FeatureSetByName($datastore,""UG_Structure"",['ObjectID',""STR_ID"",'SUBTYPE_CODE','GlobalID','Pole_GUID'],true)
var Tos = Intersects((Geometry($feature)['paths'][-1][-1]), STRs)
var IDs = []
for (var T in Tos) {
    Push(IDs,Text(T.ObjectID))
}
Console(IDs)
return IDs",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
From Pole,,CALCULATION,,From_Pole,True,True,False,True,"var Poles = FeatureSetByName($datastore,""Pole"",['ObjectID',""Pole_ID"",'SUBTYPE_CODE','GlobalID'],true)
var Froms = Intersects((Geometry($feature)['paths'][0][0]), Poles)
var IDs = []
for (var F in Froms) {
    Push(IDs,Text(F.ObjectID))
}
Console(IDs)
return IDs",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
To Pole,,CALCULATION,,To_Pole,True,True,False,True,"var Poles = FeatureSetByName($datastore,""Pole"",['ObjectID',""Pole_ID"",'SUBTYPE_CODE','GlobalID'],true)
var Tos = Intersects((Geometry($feature)['paths'][-1][-1]), Poles)
var IDs = []
for (var T in Tos) {
    Push(IDs,Text(T.ObjectID))
}
Console(IDs)
return IDs",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
Slack Span To Densified Arc,,CALCULATION,Slack Span,Shape,True,True,False,True,"var Strands = FeatureSetByName($datastore,'Strand',['ObjectID'],true)
for (var Strand in Strands) {
  Console(Strand.ObjectID)
  var chord = LengthGeodetic(Strand,'feet')
  var rad = (5*chord)/sqrt(19)
  var OffsetDist = 0.9*rad
  var OffsetSide = ''
  var CenterPt = null
  Console(OffsetDist)
  Console(rad)
  var buff = BufferGeodetic(CenterPt,rad,'feet')
}",,,False,False,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
Offset Side,,CALCULATION,,Offset_Side,True,True,False,False,"var Roads = FeatureSetByName($datastore,'Roads',['ObjectID'],true)
Console(Count(Roads))
//Geodesic measurement and converting to Planar measurement
var originShift = 2.0*PI*6378137.0/2.0
var ConvRatio = 180/originShift
var OffsetDist_Test = ConvRatio*50
var OffsetSide = ''
Console($feature.CALCULATED_LENGTH)
//Store coordinates of line
var Geom = Geometry($feature)['paths'][0]
var Paths = []
for (var pnt in Geom) {
    var pntX = Geom[pnt]['x']
    var pntY = Geom[pnt]['y']
    Push(Paths,[pntX,pntY,0,null])
}
Console('Conduit coordinates:\n' + Paths)
//RIGHT SIDE--------------------------------------------------------------------------------------
//Find Road on right side of line
//Store reversed coordinates of right offset line
var ROffset = Offset($feature, OffsetDist_Test, 'feet', 'round')
Console(iif(IsEmpty(ROffset),'empty','not empty'))
if (IsEmpty(ROffset)) {var ROffset = Offset($feature, OffsetDist_Test, 'feet', 'square')}
Console(iif(IsEmpty(ROffset),'empty','not empty'))
if (IsEmpty(ROffset)) {return null}
var ROffGeom = ROffset['paths'][0]
var ROffPaths = []
for (var pnt in ROffGeom) {
    var pntX = ROffGeom[pnt]['x']
    var pntY = ROffGeom[pnt]['y']
    Insert(ROffPaths,0,[pntX,pntY,0,null])
}
Console('Reversed right offset coordinates:\n' + ROffPaths)
//Combine Span coordinates and reversed offset coordinated to make a right side polygon
var ROffRings = Splice(Paths,ROffPaths)
Console('Spliced ring coordinates:\n' + ROffRings)
var ROffJSON = {'rings':[ROffRings],'spatialReference':{'wkid':4326}}
var ROffPoly = Polygon(ROffJSON)
Console('Area of right side polygon: ' + AreaGeodetic(ROffPoly,'square-feet'))
Console('Right side polygon:\n' + ROffPoly)
//Find intersecting Road and total lengths to determine offset side toward road
var RRoadArea = 0
var RRoads = Intersects(Roads,ROffPoly)
Console(Count(RRoads))
for (var RRoad in RRoads) {
    Console(RRoad.ObjectID)
    var RRoadBuff = BufferGeodetic(RRoad,1,'feet')
    Console('Area of Right poly: ' + AreaGeodetic(ROffPoly,'square-feet'))
    Console('Area of Road poly: ' + AreaGeodetic(Difference(ROffPoly,RRoadBuff),'square-feet'))
    var AreaDiff = AreaGeodetic(ROffPoly,'square-feet')-AreaGeodetic(Difference(ROffPoly,RRoadBuff),'square-feet')
    Console('Area of Road in right side poly: ' + AreaDiff)
    RRoadArea += AreaDiff
}
Console('Right side Road area: ' + Round(RRoadArea) + ' sqft')
//LEFT SIDE---------------------------------------------------------------------------------------
//Find Road on left side of line
//Store reversed coordinates of left offset line
var LOffset = Offset($feature, -OffsetDist_Test, 'feet', 'round')
Console(iif(IsEmpty(LOffset),'empty','not empty'))
if (IsEmpty(LOffset)) {var LOffset = Offset($feature, OffsetDist_Test, 'feet', 'square')}
Console(iif(IsEmpty(LOffset),'empty','not empty'))
if (IsEmpty(LOffset)) {return null}
var LOffGeom = LOffset['paths'][0]
var LOffPaths = []
for (var pnt in LOffGeom) {
    var pntX = LOffGeom[pnt]['x']
    var pntY = LOffGeom[pnt]['y']
    Insert(LOffPaths,0,[pntX,pntY,0,null])
}
Console('Reversed left offset coordinates:\n' + LOffPaths)
//Combine Span coordinates and reversed offset coordinated to make a left side polygon
var LOffRings = Splice(Paths,LOffPaths)
Console('Spliced ring coordinates:\n' + LOffRings)
var LOffJSON = {'rings':[LOffRings],'spatialReference':{'wkid':4326}}
var LOffPoly = Polygon(LOffJSON)
Console('Area of left side polygon: ' + AreaGeodetic(LOffPoly,'square-feet'))
Console('Left side polygon:\n' + LOffPoly)
//Find intersecting Road and total lengths to determine offset side toward road
var LRoadArea = 0
var LRoads = Intersects(Roads,LOffPoly)
Console(Count(LRoads))
for (var LRoad in LRoads) {
    Console(LRoad.ObjectID)
    var LRoadBuff = BufferGeodetic(LRoad,1,'feet')
    Console('Area of Left poly: ' + AreaGeodetic(LOffPoly,'square-feet'))
    Console('Area of Road poly: ' + AreaGeodetic(Difference(LOffPoly,LRoadBuff),'square-feet'))
    var AreaDiff = AreaGeodetic(LOffPoly,'square-feet')-AreaGeodetic(Difference(LOffPoly,LRoadBuff),'square-feet')
    Console('Area of Road in left side poly: ' + AreaDiff)
    LRoadArea += AreaDiff
}
Console('Left side Road area: ' + Round(LRoadArea) + ' sqft')
//SET SIDE----------------------------------------------------------------------------------------
//Compare total Road areas on right and left side.  Greater total is set as offset side.
OffsetSide = iif((RRoadArea > LRoadArea),'R','L')
Console('Offset side to center: ' + OffsetSide)
return OffsetSide",,,False,True,False,,,0,"{""type"":""PropertySet"",""propertySetItems"":[]}"
Strand ID,,CALCULATION,,STRAND_ID,True,True,False,False,"function Sorting(a,b) { //Sort list entries in ascending order
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    return 0;
}

Console('Pole OID: ' + $feature.OBJECTID)
var IDClasses = {'Strand':'STND:', 'OHG':'OHG:', 'PPG':'PPG:', 'Slack Span':'SLSP:', 'Default':'DEF:'}
var Type = iif(IsEmpty($feature.Strand_Type),'Other',Text($feature.Strand_Type))
if ($feature.SUBTYPE_CODE==1) {Type = 'Default'}
if (HasKey(IDClasses,Type)) {
    var Prefix = IDClasses[Type]
    var sql = ""Strand_Type = @Type""
    if ($feature.SUBTYPE_CODE==1) {sql = ""SUBTYPE_CODE = 1""}
    if ($feature.SUBTYPE_CODE==2) {sql = ""SUBTYPE_CODE = 2""}
    var FC = Filter(GetFeatureSet($feature),sql)
    var TempID = 1
   
    Console(Count(FC))
    var ExistID = []
    for (var f in FC) {
        if (f.STRAND_ID != null) {
            ExistID[Count(ExistID)] = iif(Find(':',f.STRAND_ID)>=0,Number(Split(f.STRAND_ID,':')[1]),Number(f.STRAND_ID))
        }
    }

    var SortExisting = Distinct(Sort(ExistID,Sorting))
    Console(SortExisting)
    Console(Count(SortExisting))
    if (!IsEmpty(ExistID)) {
        if (Includes(ExistID,Number(TempID))) {
            var Gap = 'No'
            Console(Text(TempID,'0000') + ' already in use')
            for (var i=0; i<Count(SortExisting)-1; i++) {
                Console(i)
                if ((SortExisting[i+1]-SortExisting[i]) != 1) {
                    Gap = 'Yes'
                    Console('Gap found after ID ' + SortExisting[i])
                    Console(SortExisting[i]+1)
                    TempID = SortExisting[i]+1
                    break
                }
                Console(i)
                Console(SortExisting[i])
                Console(SortExisting[i+1])
                Console('--------')
            }
            Console('Final i - ' + SortExisting[i])
            Console(Pop(SortExisting))
            if (Count(ExistID) == 1) {
                TempID = TempID + 1
            }
            else if (Gap == 'No') {
                TempID = SortExisting[i-1] + 2
            }
            Console(TempID)   
        }
    }
    var ID = Prefix + iif(Number(TempID)>9999,Text(TempID,'00000'),Text(TempID,'0000'))

    Console(ID)
 return ID
}",,,False,True,False,,,2147483647,"{""type"":""PropertySet"",""propertySetItems"":[]}"
Assign GUID,,CALCULATION,,Strand_GUID,True,True,False,True,"var SGUID = $feature.Strand_GUID

return iif(SGUID==null,Upper(Guid()),SGUID)",,,True,True,False,,,2147483647,"{""type"":""PropertySet"",""propertySetItems"":[]}"
